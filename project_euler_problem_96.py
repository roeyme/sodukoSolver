# -*- coding: utf-8 -*-
"""Project_Euler_Problem_96.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iiBoUi_izpzysh02dpYgdNTb5LnOBHiT

# Soduko manager Tool
The 'SodukoKing' product hendles reading,
"""

import numpy as np
import math
from enum import Enum
import copy

"""# ToolBox

The next module contains general methods that are used in building the  product
"""

"""
given an array with indicators for possible values, 
it returns an error if there is more then one option, otherwise, it returns
the sole option
"""
def findPossibleVal(valsIndicator):
    for val in range(valsIndicator.shape[0]):
        if valsIndicator[val] == 1:
            return val + 1
    return False

def findLocalGridStart(idx, n):
    idx = np.array(idx)
    lh = idx - (idx % n)
    rl = lh + n
    return lh[0], rl[0], lh[1], rl[1]

def blockshaped(arr, nrows, ncols):
    """
    Return an array of shape (n, nrows, ncols) where
    n * nrows * ncols = arr.size

    If arr is a 2D array, the returned array should look like n subblocks with
    each subblock preserving the "physical" layout of arr.
    """
    h, w = arr.shape
    assert h % nrows == 0, f"{h} rows is not evenly divisible by {nrows}"
    assert w % ncols == 0, f"{w} cols is not evenly divisible by {ncols}"
    return (arr.reshape(h//nrows, nrows, -1, ncols)
               .swapaxes(1,2)
               .reshape(-1, nrows, ncols))
    
def checkIfValidSodukoBoard(board):
    if isinstance(board, np.ndarray):
        n = board.shape[0]
        if board.ndim == 2:
            if board.shape[1] == n and n == np.floor(math.sqrt(n))**(2)\
            and np.logical_and(board >= 0, board <= n).all() \
            and (board == np.floor(board)).all():
                return True
    return False

"""# BoardState 

The class 'BoardState' is a toolbox that provides an efficient and transparent analysis of soduko boards, including executing basic actions. It is used to efficiently and easily implementing soduko solvers, in addition to partially unify the implementation of different solvers. 
"""

class BoardState:
    def __init__(self, board):
        """
        'board - the targeted soduko board
        'currentDecisionsNumber' - the number of currently applied decisions
        'statementsList' - the stack of the currently asserted statements
        'assignmentsMatrix' - matrix such that assignmentsMatrix[i][j][val] is
        1 if blank (i,j) can get the value 'val', and 0 otherwise. 
        for efficiency reasons, matrix[i][j][0] contains the number of possible 
        values for blank (i,j). If blank (i,j) was selected then matrix[i][j][0]
        is increased by the number of blanks of one row. 
        'immidiateDecisions' - the queue of immidiate decisions, i.e., a list 
        with elements of the form (idx, val) where 'idx' is an index of a blank 
        s.t., 'val' is its only possible value.  
        """
        self.board = board 
        self.currentDecisionsNumber = 0 
        self.len = board.shape[0]
        self.localGridLen = int(math.sqrt(self.len))
        self.statementsList = []
        self.assignmentsMatrix = np.ones((self.len,self.len,self.len+1),\
                                         dtype=np.int8)
        self.assignmentsMatrix[:,:,0] = self.len
        self.immidiateDecisions = []
        for i in range(self.len):
            for j in range(self.len):
                currVal = board[i][j]
                if currVal != 0:
                    self.decide((i,j), currVal)

    def getCurrentDecisionsNumber(self):
        return self.currentDecisionsNumber

    def getStatementsNum(self):
        return len(self.statementsList)
    
    def getCurrBoard(self):
        return self.board

    def findMin(self):
        """
        returns the idx of the blank with minimal number of possible values, in 
        addition to one of its possible values.
        """
        minPos = np.argmin(self.assignmentsMatrix[:,:,0])
        row = math.floor(minPos / self.len) 
        col = minPos % self.len 
        minIdx = (row, col)
        minVal = findPossibleVal(self.assignmentsMatrix[minIdx][1:])
        return (minIdx,minVal)
    
    def decide(self, idx, val, memorize = False):
        """
        apply the decision - board[idx] = val - and apply immidiate statements 
        as long as there are any
        """
        self.assignmentsMatrix[idx][0] += (self.len+1)
        self.currentDecisionsNumber += 1
        self.board[idx] = val
        if memorize:
            statement = Statement(idx, val, True)
            self.statementsList.append(statement)
        return self.deduce(idx, val, memorize)

    def eliminate(self, idx, val, memorize = False):
        """
        apply the statement 'board[idx] = val' and returns blank 'idx' is left
        with no possible values. If blank 'idx' remains with one possible value,
        then, the resultant immidiate decision is added to 
        self.immidiateDecisions
        """
        self.assignmentsMatrix[idx][val] = 0
        self.assignmentsMatrix[idx][0] -= 1
        if memorize:
            statement = Statement(idx, val, False)
            self.statementsList.append(statement)
        if  self.assignmentsMatrix[idx][0] == 0:
            return True
        if self.assignmentsMatrix[idx][0] == 1:
            newVal = findPossibleVal(self.assignmentsMatrix[idx][1:])
            self.immidiateDecisions.append((idx, newVal))
        return False

    def undoDecision(self, idx):
        self.assignmentsMatrix[idx][0] -= (self.len+1)
        self.board[idx] = 0 
        self.currentDecisionsNumber -= 1
    
    def undoElimination(self, idx, val):
        self.assignmentsMatrix[idx][val] = 1
        self.assignmentsMatrix[idx][0] += 1

    def undoStatement(self, statement):
        idx, val, sign = statement.getStatement()
        if sign:
            self.undoDecision(idx)
        else:
            self.undoElimination(idx,val)

    def deduce(self, idx, val, memorize = False):
        """
         'deduce immidiate statements that stem from the decision 
         'board[idx] = val', until there are none
        """
        i, j = idx
        #eliminate from row
        for colIndex in range(self.len): 
            if self.assignmentsMatrix[i][colIndex][val] and \
            self.board[i][colIndex] == 0:
                newIdx = (i,colIndex)
                if self.eliminate(newIdx, val, memorize):
                    return True
                
        #eliminate from column        
        for rowIndex in range(self.len): #eliminate from rows
            if self.assignmentsMatrix[rowIndex][j][val] and \
            self.board[rowIndex][j] == 0:
                newIdx = (rowIndex,j)
                if self.eliminate(newIdx, val, memorize):
                    return True
                
        #eliminate from local grid
        """
        the next line could be computed for each blank seperately at the
        beginning, but due to simplicity reasons and since its O(1), we dont
        do it here.
        """
        leftRow, rightRow, leftCol, rightCol = \
            findLocalGridStart(idx,self.localGridLen)
        for localGridRow in range(leftRow, rightRow):
            for localGridCol in range(leftCol, rightCol):
                if self.assignmentsMatrix[localGridRow][localGridCol][val] and \
                self.board[localGridRow][localGridCol] == 0:
                    newIdx = (localGridRow,localGridCol)
                    if self.eliminate(newIdx, val, memorize):
                        return True 
        return self.executeImmidiateDecisions(memorize)
            
    def executeImmidiateDecisions(self, memorize = False):
        while self.immidiateDecisions:
            idx, val = self.immidiateDecisions.pop(0)
            if self.decide(idx, val, memorize):
                return True
        return False

    def backStep(self, idx):
        """
        reverse to the time right after statement 'statementList[idx]' was
        executed, i.e., undo all statements that appear in index 'idx' or above
        in the statements stack
        """
        for statement in self.statementsList[idx:]:
            self.undoStatement(statement) 
        self.statementsList = self.statementsList[:idx]
        self.immidiateDecisions = []

class Statement():
    def __init__(self, blank, val, sign):
        self.blank = blank
        self.val = val
        self.sign = sign
    
    def getStatement(self):
        return self.blank, self.val, self.sign

"""# SodukoSolver
This class is not accessed by the end-user and provides
a toolbox of soduko solvers that use the 'boardAnalyzer' module
"""

class SodukoSolver:
    """
    A toolbox of soduko solvers that uses the 'boardAnalyzer' module.
    currently, it provides only a single solver, but using the modular design,
    more solutions can be easily added. 
    """
    def __init__(self, board):
        self.n = board.shape[0]
        self.blanksNum = self.n**(2)
        self.board = board
        self.boardAnalyzer = BoardState(board)

    def getSolution(self):
        if self.solve():
            return True, self.boardAnalyzer.board
        return False, -1

    def solve(self, numOfStatements=0):
        """
        until solution is found, 'guess' a value for some blank with minimal
        number of possible values (to reach contradictions faster) and deduce
        all of the immediate statements. If a 
        contradiction is encountered, then go back to the previous guess point 
        and guess a different value for the same index. 
        """
        if self.boardAnalyzer.getCurrentDecisionsNumber() < self.blanksNum:
            minIdx, minVal = self.boardAnalyzer.findMin()
            for val in range(1, self.n+1):
                if self.boardAnalyzer.assignmentsMatrix[minIdx][val]:
                    if not self.boardAnalyzer.decide(minIdx, val, memorize=True):
                        if self.solve(self.boardAnalyzer.getStatementsNum()):
                            return True
                    self.boardAnalyzer.backStep(numOfStatements)
            return False
        return True

"""# BoardsManager
This class BoardsManager is used direclty by the end-user. This class handles reading, solving, storing and displaying soduko boards.
"""

class BoardsManager:
    def __init__(self, source = None):
        self.boardsList = []
        self.solutions = []
        self.resultsList = []
        if source != None:
            self.readBoards(source)

    def readBoards(self, source):
        """
        reads boards to a list of np.arrays from 'source'. 'source can be either
        a list of np.arrays, or a file path. if its the latter, then the file 
        should be with the required format (that of the 'soduko.txt' file). 
        """
        newBoards = []
        if isinstance(source, str):
            newBoards = self.readBoardsFromFile(source)
        elif isinstance(source, list):
            newBoards = source
        elif isinstance(source, np.ndarray):
            newBoards = [source]
        else:
            raise Exception('recieved an invalid type of source')
        for idx, board in enumerate(newBoards):
            assert checkIfValidSodukoBoard(board), \
            f'board {idx} is not a invalid soduko board'
        self.boardsList += newBoards

    def readBoardsFromFile(self, boardsFile):
        newBoardsList = []
        with open(boardsFile) as f:
            lines = f.readlines()
            board = []
            for line in lines:
                line = line.replace(' ', '').replace('\n','')
                if not line.isnumeric():
                    if board:
                        board = np.array(board, dtype=np.int8)
                        newBoardsList.append(board)
                        board = []
                else:
                    board.append(list(line))
            board = np.array(board, dtype=np.int8)
            newBoardsList.append(board)
            return newBoardsList

    def getSolutions(self, indices = None):
        if indices == None:
            indices = range(len(self.solutions))
        for i in indices:
            assert  isinstance(i, int), \
            f'index {i} is not integer'
            assert np.abs(i) <= len(self.solutions), \
            f'index {i} is out of range'
        return self.solutions, self.resultsList

    def displaySolutions(self, indices = None):
        if indices == None:
            indices = range(len(self.solutions))
        for i in indices:
            assert  isinstance(i, int), \
            f'index {i} is not integer'
            assert np.abs(i) <= len(self.solutions), \
            f'index {i} is out of range'
            print(f'The solution of board {i} is\n{self.solutions}')
    
    def solveBoards(self, preserveOriginalBoards = True):
        self.solutions = []
        self.resultsList = []
        for board in self.boardsList:
            if preserveOriginalBoards:
                boardCpy = copy.deepcopy(board)
                CurrSolver = SodukoSolver(boardCpy)
            CurrSolver = SodukoSolver(board)
            res, solution = CurrSolver.getSolution()
            self.resultsList.append(res)
            self.solutions.append(solution)

"""This module provides a tool box to check solutions of soduko boards"""

def checkSolutions(listOfBoards, listOfSolutions):
    listOfResults = []
    for idx, board in enumerate(listOfBoards):
        solution = listOfSolutions[idx]
        assert checkIfValidSodukoBoard(board), f'board {idx} is invalid'
        assert checkIfValidSodukoBoard(solution), \
        f'solution {idx} is invalid'
        listOfResults.append(checkSolution(board, solution))
    return listOfResults

def checkSolution(board, solution):
        #check if 'solution' board is consistent with 'board'
        if board.shape != solution.shape:
            print('jhh')
            return False
        elif (board[board != 0] != solution[board != 0]).any():
            print(board)
            print(solution)
            return False
        n = board.shape[0]
        np.arange(n+1)
        #check if 'solution' is legal
        for row in board: #check rows
            if np.unique(row).shape[0] < row.shape[0]:
                return False
        for row in board.T: #check columns
            if np.unique(row).shape[0] < row.shape[0]:
                return False
        #check localGrids
        localGridLen = int(math.sqrt(n))
        localGridsList = blockshaped(board, localGridLen, localGridLen) 
        for localGrid in localGridsList:
            if np.unique(localGrid).size < np.array(localGrid).size:
                return False        
        return True

"""The following script solves the Eular96 task"""

source = '/content/soduko.txt'
menager = BoardsMenager(source)
menager.solveBoards(preserveOriginalBoards=True)
solvedBoards = np.array(menager.getSolutions()[0])
ans = np.sum(solvedBoards[:,:,:3] * np.array([100,10,1]))
print(f'the answer is {ans}')

checkSolutions(menager.boardsList, menager.getSolutions()[0])